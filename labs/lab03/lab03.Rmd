---
title: "Stats 306: Lab 3"
subtitle: "Working with tables"
author: "Your Name"
output: html_document
---

## Set up

```{r installPackages, echo=FALSE, include=FALSE, message=FALSE}
# This just checks if students need to install some packages that they might 
# not have.
```

```{r setup, echo=TRUE}
library(tidyverse)  # For ggplot2, dplyr
```


## Table operations

Today we are going to focus on functions in the `dplyr` package, which is part of the `tidyverse`. 
The `dplyr` package aims to provide a function for each basic "verb" of data manipulation. 
Here are some common functions / "verbs" for data manipulation: 

* Rows: 
    + `filter()`: Select rows based on criteria on column values
    + `slice()`: choose rows based on locations.
    + `arrange()`: change the order of the rows.
* Columns: 
    + `select()`: Pick and choose columns to include in data.
    + `pull()`: Select a single column (similar to `data$column`).
    + `rename()`: Change the name of columns.
    + `mutate()`: Change the values of columns / creates new columns. 
* Groups (of rows):
    + `group_by()`: Creates a group of rows.
    + `summarise()` or `summarize()`: Calculate summary values for a given group. 

## `select()`, `filter()`, `mutate()` Examples

We are going to look at the `midwest` data again.

```{r}
head(midwest)
```

`select()` let's us select, or deselect, columns of interest

```{r midwestSelect1, exercise=TRUE}
midwest %>%
  select(popwhite, popwhite) %>%
  head()
```

```{r midwestSelect2, exercise=TRUE}
midwest %>%
  select(-PID, -poptotal) %>%
  head()
```

We can also select by condition: 

```{r midwestSelect3, exercise=TRUE}
midwest %>%
  select(where(is.character)) %>%
  head()
```

`filter()` allows us to select certain rows. 

```{r midwestFilter1, exercise=TRUE}
midwest %>%
  filter(state == 'MI') %>%
  head()
```

You can include more than one condition at a time: 

```{r midwestFilter2, exercise=TRUE}
midwest %>%
  filter(state == "MI", county == 'WASHTENAW')
```

**Exercise**: Subset the `midwest` data so that you only have data from the states of Wisconsin and Ohio, and only have the columns: `state`, `popdensity`, `inmetro`, and `percollege`. 

```{r midwestExercise1, exercise=TRUE}
midwest
```

## `filter` and `select` Solution

There are a few possible solutions. 
Here are two: 

```{r midwestSolution1}
midwest %>%
  filter(state %in% c("WI", "OH")) %>%
  select(state, popdensity, inmetro, percollege)
```

```{r midwestSolution2}
midwest %>%
  filter(state == "WI" | state == "OH") %>%
  select(state, popdensity, inmetro, percollege)
```

## Mutate
`mutate()` can be used to either create or modify a column in a dataset. 
We can pipe multiple functions together. 

```{r mutate1, exercise=TRUE}
midwest %>%
  filter(state == 'MI') %>%
  mutate(school = ifelse(county == "WASHTENAW", "GO BLUE!!!", "OTHER")) %>%
  mutate(county == tolower(county)) %>%
  select(state, county, school) %>%
  tail()
```

We can use `arrange()` to order the columns of the data. 

```{r arrange1, exercise=TRUE}
midwest %>%
  select(state, county) %>%
  arrange(desc(state), county) %>%
  head()
```

Another useful tool is `slice()`. This function allows us to select certain rows. There are a few versions of this that each give different results. See `?slice` for more details.

```{r slice1, exercise=TRUE}
midwest %>%
  select(state, county, poptotal) %>%
  filter(state == "MI") %>%
  slice_max(poptotal)
```

## `group_by()` and `summarize()` (1-2 slides)

`group_by()` helps us great groups. 
The following code will get the maximum population for each state in the dataset. 

```{r groupby1, exercise=TRUE}
midwest %>%
  select(state, county, poptotal) %>%
  group_by(state) %>%
  slice_max(poptotal)
```

`summarize()` (or equivalently, `summarise()`) is a function that's not particularly useful on it's own, but when combined with `group_by()` it can be very useful.
The following code counts the number of counties in each state

```{r summarize1, exercise=TRUE}
midwest %>%
  group_by(state) %>%
  summarize(n_counties = n()) %>%
  arrange(-n_counties)
```

## `group_by()` and `summarize()` Exercise.

**Exercise**

Use `group_by()` and `summarize()` to get the total population in each state. 
Then, arrange the states so that states with the smallest population comes first.

```{r groupExercise, exercise=TRUE}
midwest
```

**BONUS** Modify your previous solution to also calculate the percentage of the population that is White, Black, and Asian. 

## `group_by()` and `summarize()` Solution

```{r}
midwest %>%
  group_by(state) %>%
  summarize(state_population = sum(poptotal)) %>%
  arrange(state_population)
```

```{r}
midwest %>%
  group_by(state) %>%
  summarize(state_population = sum(poptotal),
            precent_black = sum(popblack) / state_population,
            percet_white = sum(popwhite) / state_population,
            percent_asian = sum(popasian) / state_population) %>%
  arrange(state_population)
```

Another possibility is to do all columns that start with *pop* at the same time: 

```{r}
midwest %>%
  group_by(state) %>%
  summarize(across(starts_with("pop"), ~ sum(.) / sum(poptotal)))
```

